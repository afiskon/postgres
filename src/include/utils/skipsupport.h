/*-------------------------------------------------------------------------
 *
 * skipsupport.h
 *	  Support routines for B-Tree skip scans.
 *
 * B-Tree operator classes for discrete types can optionally provide a support
 * function for skipping.  This is used during skip scans.
 *
 * A B-tree operator class that implements skip support provides B-tree index
 * scans with a way of enumerating and iterating through every possible value
 * from the domain of indexable values.  This gives scans a way to determine
 * the next value in line for a given skip array/scan key/skipped attribute.
 * This happens at the point where the scan determines that another primitive
 * index scan is required.  The next value is used (in combination with at
 * least one additional lower-order non-skip key, taken from the SQL query) to
 * relocate the scan, skipping over many irrelevant leaf pages in the process.
 *
 * There are many data types/opclasses where implementing a skip support
 * scheme is inherently impossible (or at least impractical).  Obviously, it
 * would be wrong if the "next" value generated by an opclass was actually
 * after the true next value (any index tuples with the true next value would
 * be overlooked by the index scan).  This partly explains why opclasses are
 * under no obligation to implement skip support: a continuous type may have
 * no way of generating a useful next value.
 *
 * Skip scan generally works best with discrete types such as integer, date,
 * and boolean: types where we expect indexes to contain large groups of
 * contiguous values (in respect of the leading/skipped index attribute).
 * When gaps/discontinuities are naturally rare (e.g., a leading identity
 * column in a composite index, a date column preceding a product_id column),
 * then it makes sense for the skip scan to optimistically assume that the
 * next distinct indexable value will find directly matching index tuples.
 * The B-Tree code can fall back on explicit next-key probes for any opclass
 * that doesn't include a skip support function, but it's best to provide skip
 * support whenever possible.  The B-Tree code assumes that it's always better
 * to use the opclass skip support routine where available.
 *
 * When a skip scan "bets" that the next indexable value will find an exact
 * match, there is significant upside, without any accompanying downside.
 * When this optimistic strategy works out, the scan avoids the cost of an
 * explicit probe (used in the no-skip-support case to determine the true next
 * value in the index's skip attribute).  When the strategy doesn't work out,
 * then the scan is no worse off than it would have been without skip support.
 * The explicit next-key probes used by B-Tree skip scan's fallback path are
 * very similar to "failed" optimistic searches for the next indexable value
 * (the next value according to the opclass skip support routine).
 *
 * (FIXME Actually, nbtree does no such thing right now, which is considered a
 * blocker to commit.)
 *
 *
 * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/include/utils/skipsupport.h
 *
 *-------------------------------------------------------------------------
 */
#ifndef SKIPSUPPORT_H
#define SKIPSUPPORT_H

#include "utils/relcache.h"

typedef struct SkipSupportData *SkipSupport;

/*
 * State/callbacks used by skip arrays to procedurally generate elements.
 *
 * A BTSKIPSUPPORT_PROC function must set each and every field when called.
 * If an opclass can only set some of the fields, then it cannot safely
 * provide a skip support routine (and so must rely on the fallback strategy
 * used by continuous types, such as numeric).
 */
typedef struct SkipSupportData
{
	/*
	 * low_elem and high_elem must be set with the lowest and highest possible
	 * values from the domain of indexable values (assuming standard ascending
	 * order).  This helps the B-Tree code with finding its initial position
	 * at the leaf level (during the skip scan's first primitive index scan).
	 * In other words, it gives the B-Tree code a useful value to start from,
	 * before any data has been read from the index.
	 *
	 * low_elem and high_elem can also be used to prove that a qual is
	 * unsatisfiable in certain cross-type scenarios.
	 *
	 * low_elem and high_elem are also used by skip scans to determine when
	 * they've reached the final possible value (in the current direction).
	 * It's typical for the scan to run out of leaf pages before it runs out
	 * of unscanned indexable values, but it's still useful for the scan to
	 * have a way to recognize when it has reached the last possible value
	 * (this saves us a useless probe that just lands on the final leaf page).
	 *
	 * Note: the logic for determining that the scan has reached the final
	 * possible value naturally belongs in the B-Tree code.  The final value
	 * isn't necessarily the original high_elem/low_elem set by the opclass.
	 * In particular, it'll be a lower/higher value when B-Tree preprocessing
	 * determines that the true range of possible values should be restricted,
	 * due to the presence of an inequality applied to the index's skipped
	 * attribute.  These are range skip scans.
	 */
	Datum		low_elem;		/* lowest sorting/leftmost non-NULL value */
	Datum		high_elem;		/* highest sorting/rightmost non-NULL value */

	/*
	 * Decrement/increment functions.
	 *
	 * Returns a decremented/incremented copy of caller's existing datum,
	 * allocated in caller's memory context (in the case of pass-by-reference
	 * types).  It's not okay for these functions to leak any memory.
	 *
	 * Both decrement and increment callbacks are guaranteed to never be
	 * called with a NULL "existing" arg.  (In general it is the B-Tree code's
	 * job to worry about NULLs, and about whether indexed values are stored
	 * in ASC order or DESC order.)
	 *
	 * The decrement callback is guaranteed to only be called with an
	 * "existing" value that's strictly > the low_elem set by the opclass.
	 * Similarly, the increment callback is guaranteed to only be called with
	 * an "existing" value that's strictly < the high_elem set by the opclass.
	 * Consequently, opclasses don't have to deal with "overflow" themselves
	 * (though asserting that the B-Tree code got it right is a good idea).
	 *
	 * It's quite possible (and very common) for the B-Tree skip scan caller's
	 * "existing" datum to just be a straight copy of a value that it copied
	 * from the index.  Operator classes must be liberal in accepting every
	 * possible representational variation within the underlying data type.
	 * Opclasses don't have to preserve whatever semantically insignificant
	 * information the data type might be carrying around, though.
	 *
	 * Note: < and > are defined by the opclass's ORDER proc in the usual way.
	 */
	Datum		(*decrement) (Relation rel, Datum existing);
	Datum		(*increment) (Relation rel, Datum existing);
} SkipSupportData;

extern bool PrepareSkipSupportFromOpclass(Oid opfamily, Oid opcintype,
										  bool reverse, SkipSupport sksup);

#endif							/* SKIPSUPPORT_H */
